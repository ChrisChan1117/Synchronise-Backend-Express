// Generated by CoffeeScript 1.7.1
var RedisAdapter, async, commands, crc, fs, indexOptions, indexTypes, path, redis, uuid, _;

redis = require('redis');

uuid = require('node-uuid');

async = require('async');

crc = require('crc');

fs = require('fs');

path = require('path');

_ = require('underscore');

indexTypes = require('./index_types');

commands = {};

indexOptions = {};

RedisAdapter = (function() {
  function RedisAdapter(config, connection, opts) {
    this.client = redis.createClient(config.port, config.host, opts);
    this.customTypes = {};
    this.blank = function() {};
  }

  RedisAdapter.prototype.isSql = false;

  RedisAdapter.index = function(model, property, indexType) {
    var modelOptions;
    modelOptions = indexOptions[model];
    if (modelOptions == null) {
      modelOptions = {};
    }
    modelOptions[property] = indexType;
    return indexOptions[model] = modelOptions;
  };

  RedisAdapter.prototype.connect = function(callback) {
    var rootPath, self;
    self = this;
    rootPath = path.dirname(fs.realpathSync(__filename));
    return async.series([
      function(next) {
        var filename;
        if (commands.keysFor != null) {
          return next();
        }
        filename = path.join(rootPath, "./keys_for.lua");
        return fs.readFile(filename, 'utf8', function(err, lua) {
          if (err != null) {
            return typeof callback === "function" ? callback(err) : void 0;
          }
          return self.client.script('load', lua, function(err, sha) {
            commands.keysFor = sha;
            return next(err);
          });
        });
      }, function(next) {
        var filename;
        if (commands.mhgetAll != null) {
          return next();
        }
        filename = path.join(rootPath, "./mhgetall.lua");
        return fs.readFile(filename, 'utf8', function(err, lua) {
          if (err != null) {
            return typeof callback === "function" ? callback(err) : void 0;
          }
          return self.client.script('load', lua, function(err, sha) {
            commands.mhgetAll = sha;
            return next(err);
          });
        });
      }, function(next) {
        var filename;
        if (commands.createIndex != null) {
          return next();
        }
        filename = path.join(rootPath, "./create_index.lua");
        return fs.readFile(filename, 'utf8', function(err, lua) {
          if (err != null) {
            return typeof callback === "function" ? callback(err) : void 0;
          }
          return self.client.script('load', lua, function(err, sha) {
            commands.createIndex = sha;
            return next(err);
          });
        });
      }, function(next) {
        var filename;
        if (commands.updateIndex != null) {
          return next();
        }
        filename = path.join(rootPath, "./update_index.lua");
        return fs.readFile(filename, 'utf8', function(err, lua) {
          if (err != null) {
            return typeof callback === "function" ? callback(err) : void 0;
          }
          return self.client.script('load', lua, function(err, sha) {
            commands.updateIndex = sha;
            return next(err);
          });
        });
      }, function(next) {
        var filename;
        if (commands["delete"] != null) {
          return next();
        }
        filename = path.join(rootPath, "./delete.lua");
        return fs.readFile(filename, 'utf8', function(err, lua) {
          if (err != null) {
            return typeof callback === "function" ? callback(err) : void 0;
          }
          return self.client.script('load', lua, function(err, sha) {
            commands["delete"] = sha;
            return next(err);
          });
        });
      }
    ], function(err) {
      var alreadyConfiguredLua;
      alreadyConfiguredLua = true;
      if (callback != null) {
        return callback(err);
      }
    });
  };

  RedisAdapter.prototype.ping = function(callback) {
    if (callback != null) {
      return callback();
    }
  };

  RedisAdapter.prototype.close = function(callback) {
    if (this.client != null) {
      this.client.quit();
    }
    if (callback != null) {
      return callback();
    }
  };

  RedisAdapter.prototype.propertyToValue = function(value, property) {
    var typeHandler;
    typeHandler = this.customTypes[property.type];
    if (typeHandler && "propertyToValue" in typeHandler) {
      return typeHandler.propertyToValue(value);
    }
    return value;
  };

  RedisAdapter.prototype.valueToProperty = function(value, property) {
    var typeHandler, v;
    if (property["type"] === "number") {
      v = parseFloat(value);
      if (isNaN(v)) {
        v = null;
      }
      return v;
    }
    if (property["type"] === "boolean") {
      return value === 'true' || value === '1' || value === 1 || value === true;
    }
    if (property["type"] === "text") {
      if (value === 'null') {
        return null;
      }
    }
    if (property["type"] === "date") {
      if (value == null) {
        return null;
      }
      v = new Date(Date.parse(value));
      if (isNaN(v)) {
        v = null;
      }
      return v;
    }
    typeHandler = this.customTypes[property.type];
    if (typeHandler && "valueToProperty" in typeHandler) {
      return typeHandler.valueToProperty(value);
    }
    return value;
  };

  RedisAdapter.prototype.on = function(event, callback) {
    return this;
  };

  RedisAdapter.prototype.find = function(fields, table, conditions, opts, callback) {
    var self;
    if (callback == null) {
      return;
    }
    self = this;
    return self.keysFor(table, conditions, opts, function(err, keys) {
      if (err != null) {
        return callback(err);
      }
      return self.mgetKeys(keys, function(err, results) {
        if (err != null) {
          return callback(err);
        }
        return self.recheckConditionals(results, conditions, callback);
      });
    });
  };

  RedisAdapter.prototype.insert = function(table, data, id_prop, callback) {
    var idName, idValue, key, self;
    self = this;
    idName = id_prop[0]["name"];
    idValue = data[idName];
    if (idValue == null) {
      idValue = uuid.v4();
      data[idName] = idValue;
    }
    key = "" + table + ":id:" + idValue;
    return self.client.hmset(key, data, function(err) {
      var args, prop, props, score, storage, value, _i, _len;
      if ((err != null) && (callback != null)) {
        return callback(err);
      }
      props = Object.keys(data);
      args = [commands.createIndex, 0, props.length];
      for (_i = 0, _len = props.length; _i < _len; _i++) {
        prop = props[_i];
        value = data[prop];
        score = self.score(value);
        storage = self.storageFor(table, prop, value);
        args.push("" + table + ":" + prop);
        args.push(storage);
        args.push(score);
        args.push(key);
      }
      return self.client.evalsha(args, function(err) {
        if (callback != null) {
          return callback(err, {
            idName: idValue
          });
        }
      });
    });
  };

  RedisAdapter.prototype.update = function(table, changes, conditions, callback) {
    var args, id, key, prop, props, score, self, storage, value, _i, _len;
    self = this;
    if (callback == null) {
      callback = self.blank;
    }
    id = conditions["id"];
    props = Object.keys(changes);
    key = "" + table + ":id:" + id;
    args = [commands.updateIndex, 0, props.length];
    for (_i = 0, _len = props.length; _i < _len; _i++) {
      prop = props[_i];
      value = changes[prop];
      score = self.score(value);
      storage = self.storageFor(table, prop, value);
      args.push("" + table + ":" + prop);
      args.push(prop);
      args.push(storage);
      args.push(score);
      args.push(value);
      args.push(key);
    }
    return self.client.evalsha(args, function(err) {
      return callback(err);
    });
  };

  RedisAdapter.prototype.remove = function(table, conditions, callback) {
    var self;
    self = this;
    if (callback == null) {
      callback = self.blank;
    }
    return self.keysFor(table, conditions, {}, function(err, keys) {
      if (err != null) {
        return callback(err);
      }
      return async.eachSeries(keys, function(key, next) {
        var args;
        args = [commands["delete"], 0, table, key];
        return self.client.evalsha(args, next);
      }, callback);
    });
  };

  RedisAdapter.prototype.count = function(table, conditions, opts, callback) {
    var self;
    if (callback == null) {
      callback(null, []);
    }
    self = this;
    return self.keysFor(table, conditions, opts, function(err, keys) {
      if (err != null) {
        return callback(err);
      }
      return callback(err, [
        {
          c: keys.length
        }
      ]);
    });
  };

  RedisAdapter.prototype.clear = function(table, callback) {
    var self;
    self = this;
    return this.client.keys("" + table + ":*", function(err, keys) {
      if ((callback != null) && ((err != null) || keys === null || keys.length === 0)) {
        return callback(err);
      }
      return self.client.del(keys, function(err) {
        if (callback != null) {
          return callback(err);
        }
      });
    });
  };

  RedisAdapter.prototype.eagerQuery = function(association, opts, ids, callback) {
    if (callback != null) {
      return callback();
    }
  };

  RedisAdapter.prototype.score = function(value) {
    var score;
    if (typeof value === "string") {
      score = parseInt(crc.crc32(value), 16);
      return score;
    }
    if (!((value != null) && isNaN(value) === false)) {
      return "-inf";
    }
    if (typeof value === "number") {
      return value;
    }
    if (value instanceof Date) {
      return value.getTime();
    }
    if (typeof value === "boolean") {
      if (value === true) {
        return 1;
      }
      if (value === false) {
        return 0;
      }
    }
    return 0;
  };

  RedisAdapter.prototype.storageFor = function(model, prop, value) {
    var modelOptions;
    modelOptions = indexOptions[model];
    if (modelOptions != null) {
      if (modelOptions[prop] != null) {
        return modelOptions[prop];
      }
    }
    if (typeof value === "boolean") {
      return indexTypes.discrete;
    }
    return indexTypes.series;
  };

  RedisAdapter.prototype.mgetKeys = function(keys, callback) {
    var args, self;
    self = this;
    args = [commands.mhgetAll, 0, keys.length].concat(keys);
    return self.client.evalsha(args, function(err, rawResults) {
      var i, obj, rawResult, results, _i, _len;
      results = [];
      if (rawResults != null) {
        for (_i = 0, _len = rawResults.length; _i < _len; _i++) {
          rawResult = rawResults[_i];
          obj = {};
          i = 0;
          while (i !== rawResult.length) {
            obj[rawResult[i]] = rawResult[i + 1];
            i += 2;
          }
          results.push(obj);
        }
      }
      return callback(err, results);
    });
  };

  RedisAdapter.prototype.scoreRange = function(model, prop, conditions, callback) {
    var comparator, err, lowerScore, scores, self, storage, upperScore, v, value, _i, _len;
    value = null;
    self = this;
    comparator = "eq";
    if (conditions[prop].sql_comparator != null) {
      comparator = conditions[prop].sql_comparator();
      value = conditions[prop]["val"];
    } else {
      value = conditions[prop];
    }
    storage = self.storageFor(model, prop, value);
    lowerScore = "-inf";
    upperScore = "+inf";
    if (comparator === "ne") {
      err = new Error("Unsupported operator");
      err.code = 4001;
      return callback(err);
    } else if (comparator === "lt") {
      upperScore = self.score(value) - 1;
    } else if (comparator === "lte") {
      upperScore = self.score(value);
    } else if (comparator === "gt") {
      lowerScore = self.score(value) + 1;
    } else if (comparator === "gte") {
      lowerScore = self.score(value);
    } else if (comparator === "between") {
      lowerScore = self.score(conditions[prop]["from"]);
      upperScore = self.score(conditions[prop]["to"]);
    } else {
      if ((value.length != null) && typeof value === 'object') {
        scores = [];
        for (_i = 0, _len = value.length; _i < _len; _i++) {
          v = value[_i];
          scores.push(self.score(v));
        }
        return callback(null, storage, scores, null);
      }
      lowerScore = self.score(value);
      upperScore = lowerScore;
    }
    return callback(null, storage, lowerScore, upperScore);
  };

  RedisAdapter.prototype.keysFor = function(table, conditions, opts, callback) {
    var idValue, limit, offset, self;
    if (typeof opts.limit === "number") {
      limit = opts.limit;
    }
    if (typeof opts.offset === "number") {
      offset = opts.offset;
    }
    self = this;
    if (conditions === null || Object.keys(conditions).length === 0) {
      return self.performZRangeByScore("" + table + ":id", "-inf", "inf", limit, offset, function(err, keys) {
        return callback(err, keys);
      });
    } else if (conditions["id"] != null) {
      idValue = conditions["id"];
      return callback(null, ["" + table + ":id:" + idValue]);
    } else {
      return async.map(Object.keys(conditions), function(prop, next) {
        return self.scoreRange(table, prop, conditions, function(err, storage, lowerScore, upperScore) {
          var op;
          if (err != null) {
            return next(err);
          }
          if (storage === indexTypes.discrete) {
            op = "set";
          } else if ((lowerScore.length != null) && typeof lowerScore === 'object') {
            op = "in";
            lowerScore = lowerScore.join(',');
          } else {
            op = "between";
          }
          return next(err, ["" + table + ":" + prop, op, lowerScore, upperScore]);
        });
      }, function(err, conditions) {
        var args, queryId;
        if (err != null) {
          return callback(err);
        }
        queryId = uuid.v4();
        if (offset == null) {
          offset = 0;
        }
        if (limit == null) {
          limit = 999999;
        }
        args = [commands.keysFor, 0, queryId, limit, offset, conditions.length].concat(_.flatten(conditions));
        return self.client.evalsha(args, function(err, keys) {
          if (keys === "ERROR") {
            err = new Error("Query too large");
            err.code = 4000;
            return callback(err);
          }
          return callback(err, keys);
        });
      });
    }
  };

  RedisAdapter.prototype.performZRangeByScore = function(key, min, max, limit, offset, callback) {
    var args;
    args = [key, min, max];
    if ((limit != null) || (offset != null)) {
      args.push("LIMIT");
      if (offset != null) {
        args.push(offset);
      }
      if (offset == null) {
        args.push(0);
      }
      if (limit != null) {
        args.push(limit);
      }
    }
    args.push(callback);
    return this.client.zrangebyscore.apply(this.client, args);
  };

  RedisAdapter.prototype.recheckConditionals = function(results, conditions, callback) {
    var self;
    self = this;
    if (results == null) {
      results = [];
    }
    return async.filter(results, function(result, next) {
      var keep, prop, value, _i, _len, _ref;
      keep = true;
      if (result == null) {
        return next(false);
      }
      _ref = Object.keys(conditions);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        prop = _ref[_i];
        value = null;
        if (conditions[prop].sql_comparator != null) {
          value = conditions[prop]["val"];
        } else {
          value = conditions[prop];
        }
        if (typeof value === "string") {
          if (result[prop] !== value) {
            keep = false;
            break;
          }
        }
      }
      return next(keep);
    }, function(results) {
      return callback(null, results);
    });
  };

  return RedisAdapter;

})();

module.exports = RedisAdapter;
